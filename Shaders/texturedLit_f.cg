//Pass an argument to the shader compiler for highest optimization level
#pragma argument (O4; fastmath; fastprecision; fastint)
#pragma branch(flatten: always)
#pragma loop(unroll: always)

// Per frame uniforms are the same for all entities in the frame
// These don't change between draw calls (only frame to frame)
struct PerFrameFragmentUniforms
{
	unsigned int u_lightCount;	// 4 bytes
	float4 u_lightPositions[8];	// 128 bytes
	float4 u_lightColors[8];	// 128 bytes
	float u_lightPowers[8];		// 32 bytes
	float u_lightRadii[8];		// 32 bytes
	float3 u_cameraPosition;	// 12 bytes
};

PerFrameFragmentUniforms u_perPFrame : BUFFER[0];

static const half PI = 3.14159265;
static const half INV_PI = 0.31831; // 1/pi

void main(
	half2 pass_texCoord : TEXCOORD0_HALF,
	half4 pass_surfaceNormal : TEXCOORD1_HALF,
	half4 pass_worldPosition : TEXCOORD2_HALF,

	uniform sampler2D u_texture, // per group, set via texture binding

	out half4 out_color : COLOR)
{
	// Start with ambient
	half3 totalLight = half3(0.05, 0.05, 0.05);

	half3 N = normalize(pass_surfaceNormal.xyz);
	// Calculate the view direction for specular lighting
	half3 viewDir = normalize(u_perPFrame.u_cameraPosition - pass_worldPosition.xyz);
	
	for(unsigned int i = 0; i < u_perPFrame.u_lightCount; i++)
    {
		half r = (half)u_perPFrame.u_lightRadii[i];
		half r2 = r * r;
		half invR = half(1.0) / r;

		half3 surfaceToLight = u_perPFrame.u_lightPositions[i].xyz - pass_worldPosition.xyz;
		half distSq = dot(surfaceToLight, surfaceToLight); //faster than length2

		// mask for whether we're inside the radius of a light
		half inside = step(distSq, r2);

		half invD = rsqrt(distSq); // Reciprocal square root (often faster than sqrt + divide)
		//Light direction
		half3 L = surfaceToLight * invD;

		// N.L * mask
		half NdotL = saturate(dot(N, L)) * inside;

		// attenuation = (power * (1 - dist/r)) / (pi * dSquared)
		half dist = distSq * invD;
		half fall = (u_perPFrame.u_lightPowers[i] * (1 - dist * invR)) * INV_PI / distSq;
		half attn = max(fall, 0.0f) * inside;

		// Blinn spec ^16
		half3 H = normalize(L + viewDir);
		half spec = saturate(dot(N, H));
		spec = spec * spec; // ^2
		spec = spec * spec; // ^4
		spec = spec * spec; // ^8
		spec = spec * spec;

		spec = spec * inside;

		//accumulate
		half3 C = u_perPFrame.u_lightColors[i].xyz;
		totalLight += C * (NdotL * attn + 0.5 * spec * attn);
	}

	// Clamp the total light to prevent overbrightening
	half3 clampedLight = min(totalLight, half3(1.0, 1.0, 1.0));

	// Sample the texture
	half4 texColor = tex2D(u_texture, pass_texCoord);

	// Combine the texture color with the lighting
	out_color = half4(texColor.rgb * clampedLight, texColor.a);
	//out_color = half4(surfaceNormal, 1.0);
}
